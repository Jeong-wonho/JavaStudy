여러테이블의 컬럼을 검색하다.
SELECT a.컬럼1, b.컬럼2 ~~~
-> JOIN 사용

여러테이블의 행을 검색한다
-> 집합연산자 
SELECT 컬럼1
FROM a
UNION
SELECT 컬럼2
FROM b

처리 순서를 갖는 한테이블의 컬럼들을 검색한다
SELECT a.컬럼1, a.컬럼2, a.컬럼3
FROM a
WHERE a.컬럼1 = (SELECT b.컬럼2 FROM b WHERE ~)

--직책 (job_title)이 'President'인 사원의 사번, 이름을 출력하시오.
SUBQUERY로 해결 : 


JOIN으로 해결 :

-----------------------------------------------------------------------------------------

--ROWNUM 의사컬럼
SELECT rownum, employee_id,first_name
FROM employees;

SELECT rownum, job_id, job_title
FROM jobs;

SELECT rownum, employee_id,first_name
FROM employees
ORDER BY salary DESC;

--급여순으로 내림차순한 사원중 급여 많이 받는 5명을 출력하시오.
SELECT rownum, employee_id,first_name, salary
FROM employees
WHERE rownum BETWEEN 1 AND 5
ORDER BY salary DESC; --X

SELECT rownum, employee_id, first_name, salary
FROM (SELECT*FROM employees ORDER BY salary DESC)
WHERE rownum BETWEEN 1 AND 5;

--급여순으로 내림차순한 사원중 급여많이 받는 6번째~10번째 사원들을 출력하시오
SELECT rownum, employee_id, first_name, salary
FROM (SELECT*FROM employees ORDER BY salary DESC)
WHERE rownum BETWEEN 6 AND 10;

SELECT rn,employee_id, first_name, salary
FROM ( SELECT rownum rn, a.*
       FROM (SELECT*FROM employees ORDER BY salary DESC)a
       )
WHERE rn BETWEEN 6 AND 10;

-----------------------------------------------------------------------------------------

서브쿼리의 특징
1. () 연산자 사용한다
2. 서브쿼리에서 ORDER BY절 사용할 수 없다
3. 단일컬럼을 반환하는 서브쿼리는 메인쿼리의 WHERE절에서도 단일 컬럼과 비교한다
	WHERE b1 = (SELECT a1);
	
	여러컬럼을 반환하는 서브쿼리경우 메인쿼리의 WHERE절에서도  여러컬럼과 비교한다
	WHERE (b1,b2) = (SELECT a1,a2);
--부서별 최대급여를 출력하시오
SELECT depatment_id, MAX(salary)
FROM employees
GROUP BY department_id;

--부서별 최대급여를 출력하시오
SELECT depatment_id, AVG(salary)
FROM employees
GROUP BY department_id;

--부서별 평균급여보다 많은 급여를 받는 사원들의 사번, 급여, 부서번호를 출력하시오
SELECT employee_id, salary, department_id
FROM employees
WHERE salary > (SELECT AVG(salary)
	FROM employees
	GROUP BY department_id);

4. 단일행을 반환하는 서브쿼리는 WHERE절에서 일반연사잔와 비교한다 ( =, <>, >, <, >=, <=)
   여러행을 반환하는 서브쿼리는 WHERE절에서 IN, ANY, ALL연산자와 비교한다

-----------------------------------------------------------------------------------------

객체종류
- 테이블
- 뷰
- 인덱스
- 시퀀스

** 객체생성, 변경, 제거하는 DD(정의)L **
CREATE TABLE
ALTER TABLE
DROP TABLE
TRUNCATE TABLE

테이블 객체 생성
-- 고객이 상품을 주문한다
-- 고객ID, 고객비번, 상품번호, 상품이름, 주문수량, 주문일자
       1	      1	   C0001   아메리카노     5      21/05/31
       1         1	   C0001   아메리카노     3      21/05/31
------------------------------------------------------------------------

<정교화 작업>

--[고객]
고객ID	고객비번

--[상품]
상품번호 상품이름

--[주문]
고객ID 상품번호 주문수량 주문일자

--[주문상세]
주문번호 상품번호 주문수량
------------------------------------------------------------------------

--고객 테이블 생성(table명은 되도록 영어로)
CREATE TABLE customer(
    id VARCHAR2(10),
    pwd VARCHAR2(10),
    name VARCHAR2(10)
);

CREATE TABLE product(
    prod_no VARCHAR2(10),
    prod_name VARCHAR2(30),
    prod_price NUMBER(8),
    prod_mf_dt DATE
    );
--(우편번호용 식별자 컬럼인 건물번호) 컬럼 추가
ALTER TABLE customer
ADD buildingno CHAR(25);

-- 고객 테이블 제거
DROP TABLE customer;

------------------------------------------------------------------------

--DML[데이터 조작어] - INSERT INTO, DELETE, UPDATE
--고객 테이블에 행추가
INSERT INTO customer (id,pwd,name,buildingno) VALUES ('id1','p1','n1',NULL);
INSERT INTO customer (id,pwd,name,buildingno) VALUES ('id2','p2','n2','');
INSERT INTO customer (id,pwd,name) VALUES ('id3','p3','n3'); --buildingno 자동으로 NULL이 삽입됨
INSERT INTO customer VALUES ('id4','p4','n4','');

SELECT* FROM customer;

--옳지 않은 데이터를 고객테이블에 추가
INSERT INTO customer (id,pwd,name) VALUES ('id1','p4','n4'); -- 중복된 아이디 입력 성공

--옳지 않은 데이터 고객 테이블에서 삭제
DELETE FROM customer WHERE id = 'id1';4
DELETE FROM customer;

--이상치, 결측치는 추가되지 않도록 테이블을 생성해야한다.
--제약조건을 설정하여 테이블을 생성해야한다.
--제약조건 종류 : NOT NULL, UNIQUE, PRIMARY KEY, CHECK, FOREIGN KEY
--NOT NULL 제약조건은 테이블 레벨로 설정할 수 없다. 컬럼레벨로만 설정할 수 있다
--테이블 생성시 컬럼레벨 제약조건 추가
 CREATE TABLE t1 (
 a varchar2(10) constraint t1_a_c NOT NULL,
 b number(5) constraint t1_b_c UNIQUE,
 :
 );
 
 --테이블 생성시 테이블레벨 제약 조건
 CREATE TABLE t1(
 a varchar2(10),
 b number(5),
 contraint t1_b_c UNIQUE,
 contraint t1_a_c PRIMARY KEY
 );
 

--이미 테이블이 생성된 경우는 ALTER TABLE로 제약조건을 추가
ALRTER TABLE customer
ADD CONSTRAINT customer_name_nn NOT NULL(name);

--고객의 name컬럼에 null값 허용안함
ALTER TABLE customer
ADD CONSTRAINT customer_name_nn NOT NULL(name); --테이블 레벨로 제약조건 추가. NOT NULL은 안됨

ALTER TABLE customer
MODIFY name CONSTRAINT customer_name_nn NOT NULL; --컬럼레벨로 제약조건 추가

--고객의 id컬럼에 null값 허용 안하고 중복허용 안함 (PRIMARY KEY : NOT NULL + UNIQUE)
ALTER TABLE customer
ADD CONSTRAINT customer_id_pk PRIMARY KEY(id);

--상품의 prod_no 컬럼에 null값 허용 안하고 중복허용 안하마 (PRIMARY KEY 제약조건 추가)
ALTER TABLE product
ADD CONStRAINT product_no_pk PRIMARY KEY(prod_no);

--상품의 prod_name 컬럼에 null값 허용 안함
ALTER TABLE product
MODIFY prod_name CONSTRAINT prod_name_nn NOT NULL;

--상품의 prod_price 컬럼에 null값 허용 안함
ALTER TABLE product
MODIFY prod_price CONSTRAINT prod_price_nn NOT NULL;

--상품의 prod_price 컬럼의 값은 0 이상
ALTER TABLE product
ADD CONSTRAINT prod_price_ck CHECK (prod_price >= 0);

----------------------------------------------------------------------------------------------
CREATE TABLE order_info(
    order_no number CONSTRAINT order_info_no_pk PRIMARY KEY,
    order_id VARCHAR(10) CONSTRAINT order_info_id_nn NOT NULL,
    order_dt DATE DEFAULT SYSDATE NOT NULL,
    CONSTRAINT order_info_id_fk FOREIGN KEY (order_id) REFERENCES customer(id)
    );


CREATE table order_line(
order_no number,
order_prod_no VARCHAR(10)--product의 prod_no를 참조해야하니까 자료형과 자릿수가 같아야함
,order_quantity number default 1 --강제입력안할때 자동들어갈 값을 기본값이라고 함. default뒤에 기본값 설정.
,CONSTRAINT order_line_pk PRIMARY KEY (order_no, order_prod_no)--복합키로 PK
,CONSTRAINT order_line_no FOREIGN KEY (order_no) REFERENCES order_info(order_no) --order_no가 주문기본 참조
,CONSTRAINT order_prod_no_fk FOREIGN KEY (order_prod_no) REFERENCES product(prod_no)); --order_prod_no가 상품 참조

----------------------------------------------------------------------------------------------

CREATE TABLE t1(
	a varchar2(5)
	b number(3,1)
	c Date
	);

CREATE TABLE dept_temp
AS SELECT * FROM dept WHERE 0 <> 1;

INSERT INTO dept_temp(deptno)
    VALUES ('50'); --문자 '50'가 숫자형으로 자동형변환됨
INSERT INTO dept_temp(deptno)
    VALUES ('ABC'); --오류발생

UPDATE employees
SET employee_id = 1
WHERE employee_id = 100;



--정리
컬럼추가, 변경, 삭제용 ALTER 명령어

1)컬럼 추가
ALTER TABLE 테이블명
ADD 컬럼명 자료형(자릿수) DEFAULT 기본값 CONSTRAINT 제약조건명 제약조건종류

2)컬럼 추가
ALTER TABLE 테이블명
RENAME COLUMN 기존컬럼명 TO 새컬럼명

3)컬럼자릿수 / 자료형 / 기본값 변경, NOT NULL 제약 조건 추가
ALTER TABLE 테이블명
MODIFY 컬럼명 새자료형(새자릿수) DEFAULT 새기본값 CONSTRAINT 제약조건명
NOT NULL

4)컬럼 삭제
ALTER TABLE 테이블명
DROP COLUMN 컬럼명

테이블레벨로 제약조건 추가
ALTER TABLE 테이블명
ADD CONSTRAINT 제약조건명 제약조건종류 컬럼명
ex)ADD CONSTRAINT customer_pk PRIMARY KEY id;
   ADD CONSTRAINT order_prod_no_fk FOREIGN KEY prod_no REFERENCESproduct(prod_no);
   ADD CONSTRAINT order_quantity_ck CHECK order_quantity > 0;

제약조건이름 변경 / 삭제
ALTER TABLE 테이블명
RENAME CONSTRAINT 기존제약조건명 TO 새제약조건명;

DROP CONSTRAINT 제약조건명;